var c=Object.defineProperty;var h=(s,e,t)=>e in s?c(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var d=(s,e,t)=>h(s,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))o(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const n of r.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&o(n)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function o(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();const l=20,m=40,u=document.getElementsByClassName("grid")[0],g={row:0,column:0,mineCount:0,isMine:!1,isFlagged:!1,isRevealed:!1};class p{constructor(){d(this,"grid",[]);d(this,"positions",[])}render(){this.setMinePositions(),this.buildGrid(),this.renderBoard(),this.setMineCounts()}renderBoard(){u.innerHTML="";for(let e of this.grid){let t=document.createElement("ul");for(let o of e){let i=this.createCell(o);t.appendChild(i)}u.appendChild(t)}}createCell(e){let t=document.createElement("li");return t.dataset.row=e.row.toString(),t.dataset.column=e.column.toString(),t.dataset.isMine=e.isMine.toString(),t.dataset.isRevealed=e.isRevealed.toString(),t.dataset.nearMine=e.mineCount!==0?"true":"false",e.mineCount>0&&(t.innerHTML=e.mineCount.toString()),t.addEventListener("click",()=>this.handleCellClick(e)),t}handleCellClick(e){this.grid[e.row][e.column].isRevealed=!0,e.mineCount===0&&this.showZeros(e),e.isMine&&this.gameOver(),this.renderBoard()}showZeros(e){this.neighborCells(e,t=>{t.mineCount===0&&!t.isRevealed&&!t.isMine&&(t.isRevealed=!0,this.showZeros(t))})}gameOver(){for(let e of this.grid)for(let t of e)t.isMine&&(t.isRevealed=!0)}setMineCounts(){for(let e in this.grid)for(let t in this.grid[e]){let o=this.grid[e][t];o.isMine||(this.neighborCells(o,i=>{i.isMine&&o.mineCount++}),this.grid[e][t]=o)}}setMinePositions(){for(let e=0;e<m;e++){let t=Math.floor(Math.random()*l),o=Math.floor(Math.random()*l);if(this.positions.includes([t,o])){e--;continue}this.positions.push([t,o])}}buildGrid(){for(let e=0;e<l;e++){let t=[];for(let o=0;o<l;o++)t.push({...g,row:e,column:o,isMine:this.positions.some(i=>i[0]===e&&i[1]===o)});this.grid.push(t),t=[]}}neighborCells(e,t){var o;for(let i=-1;i<=1;i++)for(let r=-1;r<=1;r++){if(i===0&&r===0)continue;let n=e.row+i,f=e.column+r,a=(o=this.grid[n])==null?void 0:o[f];a&&t(a)}}}const M=new p;M.render();
