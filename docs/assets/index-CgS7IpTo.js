var c=Object.defineProperty;var h=(s,e,t)=>e in s?c(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var d=(s,e,t)=>h(s,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const n of o.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&r(n)}).observe(document,{childList:!0,subtree:!0});function t(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(i){if(i.ep)return;i.ep=!0;const o=t(i);fetch(i.href,o)}})();const l=20,m=40,u=document.getElementsByClassName("grid")[0],g={row:0,column:0,mineCount:0,isMine:!1,isFlagged:!1,isRevealed:!1};class p{constructor(){d(this,"grid",[]);d(this,"positions",[])}render(){this.setMinePositions(),this.buildGrid(),this.renderBoard(),this.setMineCounts()}renderBoard(){u.innerHTML="";for(let e of this.grid){let t=document.createElement("ul");for(let r of e){let i=this.createCell(r);t.appendChild(i)}u.appendChild(t)}}createCell(e){let t=document.createElement("li");return t.dataset.row=e.row.toString(),t.dataset.column=e.column.toString(),t.dataset.isMine=e.isMine.toString(),t.dataset.isRevealed=e.isRevealed.toString(),t.dataset.nearMine=e.mineCount!==0?"true":"false",t.innerHTML=e.mineCount.toString(),t.addEventListener("click",()=>this.handleCellClick(e)),t}handleCellClick(e){this.grid[e.row][e.column].isRevealed=!0,e.mineCount===0&&this.showZeros(e),e.isMine&&this.gameOver(),this.renderBoard()}showZeros(e){this.neighborCells(e,t=>{t.mineCount===0&&!t.isRevealed&&!t.isMine&&(t.isRevealed=!0,this.showZeros(t))})}gameOver(){for(let e of this.grid)for(let t of e)t.isRevealed=!0}setMineCounts(){for(let e in this.grid)for(let t in this.grid[e]){let r=this.grid[e][t];r.isMine||(this.neighborCells(r,i=>{i.isMine&&r.mineCount++}),this.grid[e][t]=r)}}setMinePositions(){for(let e=0;e<m;e++){let t=Math.floor(Math.random()*l),r=Math.floor(Math.random()*l);if(this.positions.includes([t,r])){e--;continue}this.positions.push([t,r])}}buildGrid(){for(let e=0;e<l;e++){let t=[];for(let r=0;r<l;r++)t.push({...g,row:e,column:r,isMine:this.positions.some(i=>i[0]===e&&i[1]===r)});this.grid.push(t),t=[]}}neighborCells(e,t){var r;for(let i=-1;i<=1;i++)for(let o=-1;o<=1;o++){if(i===0&&o===0)continue;let n=e.row+i,f=e.column+o,a=(r=this.grid[n])==null?void 0:r[f];a&&t(a)}}}const M=new p;M.render();
